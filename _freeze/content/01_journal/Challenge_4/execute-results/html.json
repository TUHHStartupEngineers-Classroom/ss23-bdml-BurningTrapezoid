{
  "hash": "cbcb18f9f280b283ec76a81e1d6b0bb8",
  "result": {
    "markdown": "---\ntitle: \"Challenge 4: Performance\"\nauthor: \"Andreas Jessen\"\n---\n\n::: {.cell hash='Challenge_4_cache/html/unnamed-chunk-1_93a771b033a3ea79310beb8b3b9bdc39'}\n\n```{.r .cell-code}\n# Libraries\nlibrary(tidyverse)\nlibrary(rsample)\nlibrary(recipes)\nlibrary(h2o)\n```\n:::\n\n::: {.cell hash='Challenge_4_cache/html/unnamed-chunk-2_acc987de6deee5c9c706362bad10d4b7'}\n\n```{.r .cell-code}\n# Load data\nproduct_backorders_tbl <- read_csv(\"Data/product_backorders.csv\")\n\n# Split into test and train\nset.seed(seed = 1113)\nsplit_obj <- rsample::initial_split(product_backorders_tbl, prop = 0.85)\n\n# Assign training and test data\ntrain_readable_tbl <- training(split_obj)\ntest_readable_tbl  <- testing(split_obj)\n```\n:::\n\n::: {.cell hash='Challenge_4_cache/html/unnamed-chunk-3_0f54fd95250eda87dc237a01a4a4ade1'}\n\n```{.r .cell-code}\n# Recipe\nfactor_names <- c(\"deck_risk\", \"oe_constraint\", \"ppap_risk\", \"stop_auto_buy\", \"rev_stop\", \"went_on_backorder\")\n\nrecipe_obj <- recipe(went_on_backorder ~ ., data = train_readable_tbl) %>%\n    step_zv(all_predictors()) %>%\n    step_mutate_at(all_of(factor_names), fn = as.factor) %>%\n    step_center(all_numeric()) %>%\n    step_scale(all_numeric()) %>%\n    step_dummy(all_nominal(), -all_outcomes()) %>% \n    \n    # prepare the final recipe\n    prep()\n\ntrain_tbl <- bake(recipe_obj, new_data = train_readable_tbl)\ntest_tbl  <- bake(recipe_obj, new_data = test_readable_tbl)\n```\n:::\n\n::: {.cell hash='Challenge_4_cache/html/unnamed-chunk-4_079257718e519ff3edf1a506c3e71f5d'}\n\n```{.r .cell-code}\n# Modeling\nh2o.init()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>  Connection successful!\n#> \n#> R is connected to the H2O cluster: \n#>     H2O cluster uptime:         1 days 44 minutes \n#>     H2O cluster timezone:       Europe/Berlin \n#>     H2O data parsing timezone:  UTC \n#>     H2O cluster version:        3.40.0.4 \n#>     H2O cluster version age:    1 month and 17 days \n#>     H2O cluster name:           H2O_started_from_R_andi_gcu544 \n#>     H2O cluster total nodes:    1 \n#>     H2O cluster total memory:   2.73 GB \n#>     H2O cluster total cores:    4 \n#>     H2O cluster allowed cores:  4 \n#>     H2O cluster healthy:        TRUE \n#>     H2O Connection ip:          localhost \n#>     H2O Connection port:        54321 \n#>     H2O Connection proxy:       NA \n#>     H2O Internal Security:      FALSE \n#>     R Version:                  R version 4.3.0 (2023-04-21)\n```\n:::\n\n```{.r .cell-code}\n# Split data into a training and a validation data frame\n# Setting the seed is just for reproducability\nsplit_h2o <- h2o.splitFrame(as.h2o(train_tbl), ratios = c(0.85), seed = 1234)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> \n  |                                                                            \n  |                                                                      |   0%\n  |                                                                            \n  |======================================================================| 100%\n```\n:::\n\n```{.r .cell-code}\ntrain_h2o <- split_h2o[[1]]\nvalid_h2o <- split_h2o[[2]]\ntest_h2o  <- as.h2o(test_tbl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> \n  |                                                                            \n  |                                                                      |   0%\n  |                                                                            \n  |======================================================================| 100%\n```\n:::\n\n```{.r .cell-code}\n# Set the target and predictors\ny <- \"went_on_backorder\"\nx <- setdiff(names(train_h2o), y)\n\nautoml_models_h2o <- h2o.automl(\n  x = x,\n  y = y,\n  training_frame    = train_h2o,\n  validation_frame  = valid_h2o,\n  leaderboard_frame = test_h2o,\n  max_runtime_secs  = 30,\n  nfolds            = 5 \n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> \n  |                                                                            \n  |                                                                      |   0%\n  |                                                                            \n  |==                                                                    |   3%\n#> 18:43:22.983: User specified a validation frame with cross-validation still enabled. Please note that the models will still be validated using cross-validation only, the validation frame will be used to provide purely informative validation metrics on the trained models.\n  |                                                                            \n  |=======                                                               |  10%\n  |                                                                            \n  |============                                                          |  17%\n  |                                                                            \n  |=================                                                     |  24%\n  |                                                                            \n  |=====================                                                 |  31%\n  |                                                                            \n  |==========================                                            |  37%\n  |                                                                            \n  |===============================                                       |  44%\n  |                                                                            \n  |====================================                                  |  51%\n  |                                                                            \n  |=========================================                             |  58%\n  |                                                                            \n  |=============================================                         |  65%\n  |                                                                            \n  |==================================================                    |  71%\n  |                                                                            \n  |=======================================================               |  78%\n  |                                                                            \n  |============================================================          |  85%\n  |                                                                            \n  |================================================================      |  92%\n  |                                                                            \n  |===================================================================== |  99%\n  |                                                                            \n  |======================================================================| 100%\n```\n:::\n:::\n\n::: {.cell hash='Challenge_4_cache/html/unnamed-chunk-5_1417653d5f31e5d3659139ce0ff58b52'}\n\n```{.r .cell-code}\n# leaderboard\nh2o_leaderboard <- automl_models_h2o@leaderboard\nh2o_leaderboard\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>                                                  model_id       auc   logloss\n#> 1 StackedEnsemble_BestOfFamily_1_AutoML_5_20230614_184322 0.9491857 0.1750480\n#> 2                      XGBoost_1_AutoML_5_20230614_184322 0.9459504 0.1815148\n#> 3                          GBM_1_AutoML_5_20230614_184322 0.9438834 0.1846098\n#> 4                      XGBoost_2_AutoML_5_20230614_184322 0.8974458 0.5009576\n#> 5                          GLM_1_AutoML_5_20230614_184322 0.7761108 0.3241361\n#> 6                          GBM_2_AutoML_5_20230614_184322 0.7379113 0.3523715\n#>       aucpr mean_per_class_error      rmse        mse\n#> 1 0.7412366            0.1445822 0.2290206 0.05245044\n#> 2 0.7363856            0.1523087 0.2307181 0.05323082\n#> 3 0.7244995            0.1379415 0.2359512 0.05567296\n#> 4 0.6186540            0.1821278 0.3951702 0.15615948\n#> 5 0.3100852            0.2929375 0.3071824 0.09436101\n#> 6 0.3588417            0.3658189 0.3195467 0.10211008\n#> \n#> [7 rows x 7 columns]\n```\n:::\n:::\n\n::: {.cell hash='Challenge_4_cache/html/unnamed-chunk-6_017ded3901ff31fcdec6ab42536eebea'}\n\n```{.r .cell-code}\n# Leaderboard visualisation\nplot_h2o_leaderboard <- function(h2o_leaderboard, order_by = c(\"auc\", \"logloss\"), \n                                 n_max = 20, size = 4, include_lbl = TRUE) {\n\n    # Setup inputs\n    # adjust input so that all formats are working\n    order_by <- tolower(order_by[[1]])\n\n    leaderboard_tbl <- h2o_leaderboard %>%\n        as.tibble() %>%\n        select(-c(aucpr, mean_per_class_error, rmse, mse)) %>% \n        mutate(model_type = str_extract(model_id, \"[^_]+\")) %>%\n        rownames_to_column(var = \"rowname\") %>%\n        mutate(model_id = paste0(rowname, \". \", model_id) %>% as.factor())\n\n    # Transformation\n    if (order_by == \"auc\") {\n\n        data_transformed_tbl <- leaderboard_tbl %>%\n            slice(1:n_max) %>%\n            mutate(\n                model_id   = as_factor(model_id) %>% reorder(auc),\n                model_type = as.factor(model_type)\n            ) %>%\n                pivot_longer(cols = -c(model_id, model_type, rowname), \n                       names_to = \"key\", \n                       values_to = \"value\", \n                       names_transform = list(key = forcats::fct_inorder)\n                       )\n\n    } else if (order_by == \"logloss\") {\n\n        data_transformed_tbl <- leaderboard_tbl %>%\n            slice(1:n_max) %>%\n            mutate(\n                model_id   = as_factor(model_id) %>% reorder(logloss) %>% fct_rev(),\n                model_type = as.factor(model_type)\n            ) %>%\n            pivot_longer(cols = -c(model_id, model_type, rowname), \n                       names_to = \"key\", \n                       values_to = \"value\", \n                       names_transform = list(key = forcats::fct_inorder)\n                       )\n\n    } else {\n        # If nothing is supplied\n        stop(paste0(\"order_by = '\", order_by, \"' is not a permitted option.\"))\n    }\n\n    # Visualization\n    g <- data_transformed_tbl %>%\n        ggplot(aes(value, model_id, color = model_type)) +\n        geom_point(size = size) +\n        facet_wrap(~ key, scales = \"free_x\") +\n        labs(title = \"Leaderboard Metrics\",\n             subtitle = paste0(\"Ordered by: \", toupper(order_by)),\n             y = \"Model Postion, Model ID\", x = \"\")\n\n    if (include_lbl) g <- g + geom_label(aes(label = round(value, 2), \n                                             hjust = \"inward\"))\n\n    return(g)\n\n}\n\nplot_h2o_leaderboard(h2o_leaderboard)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Warning: `as.tibble()` was deprecated in tibble 2.0.0.\n#> ℹ Please use `as_tibble()` instead.\n#> ℹ The signature and semantics have changed, see `?as_tibble`.\n```\n:::\n\n::: {.cell-output-display}\n![](Challenge_4_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n::: {.cell hash='Challenge_4_cache/html/unnamed-chunk-7_328c4fee5b57c213f0d9e7677b176df0'}\n\n```{.r .cell-code}\n# Grid search\ndeeplearning_grid_01 <- h2o.grid(\n\n    # See help page for available algos\n    algorithm = \"deeplearning\",\n    \n    # I just use the same as the object\n    grid_id = \"deeplearning_grid_01\",\n    \n    # The following is for ?h2o.deeplearning()\n    # predictor and response variables\n    x = x,\n    y = y,\n    \n    # training and validation frame and crossfold validation\n    training_frame   = train_h2o,\n    validation_frame = valid_h2o,\n    nfolds = 5,\n    \n    # Hyperparamters: Use deeplearning_h2o@allparameters to see all\n    hyper_params = list(\n        # Use some combinations (the first one was the original)\n        hidden = list(c(10, 10, 10), c(50, 20, 10), c(20, 20, 20)),\n        epochs = c(1, 5, 10)\n    )\n)\nh2o.getGrid(grid_id = \"deeplearning_grid_01\", sort_by = \"auc\", decreasing = TRUE)\n```\n:::\n\n::: {.cell hash='Challenge_4_cache/html/unnamed-chunk-8_c1a6f97e21f3ea1882f35ba01a0ec959'}\n\n```{.r .cell-code}\nh2o.init()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>  Connection successful!\n#> \n#> R is connected to the H2O cluster: \n#>     H2O cluster uptime:         1 days 1 hours \n#>     H2O cluster timezone:       Europe/Berlin \n#>     H2O data parsing timezone:  UTC \n#>     H2O cluster version:        3.40.0.4 \n#>     H2O cluster version age:    1 month and 17 days \n#>     H2O cluster name:           H2O_started_from_R_andi_gcu544 \n#>     H2O cluster total nodes:    1 \n#>     H2O cluster total memory:   2.70 GB \n#>     H2O cluster total cores:    4 \n#>     H2O cluster allowed cores:  4 \n#>     H2O cluster healthy:        TRUE \n#>     H2O Connection ip:          localhost \n#>     H2O Connection port:        54321 \n#>     H2O Connection proxy:       NA \n#>     H2O Internal Security:      FALSE \n#>     R Version:                  R version 4.3.0 (2023-04-21)\n```\n:::\n\n```{.r .cell-code}\n# precision vs recall with optimal threshold\nperformance_h2o <- h2o.performance(automl_models_h2o@leader, newdata = as.h2o(test_tbl)) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> \n  |                                                                            \n  |                                                                      |   0%\n  |                                                                            \n  |======================================================================| 100%\n```\n:::\n\n```{.r .cell-code}\nperformance_tbl <- performance_h2o %>%\n    h2o.metric() %>%\n    as.tibble() \n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Warning: `as.tibble()` was deprecated in tibble 2.0.0.\n#> ℹ Please use `as_tibble()` instead.\n#> ℹ The signature and semantics have changed, see `?as_tibble`.\n```\n:::\n\n```{.r .cell-code}\nperformance_tbl %>%\n    ggplot(aes(x = threshold)) +\n    geom_line(aes(y = precision), color = \"blue\", size = 1) +\n    geom_line(aes(y = recall), color = \"red\", size = 1) +\n    \n    # Insert line where precision and recall are harmonically optimized\n    geom_vline(xintercept = h2o.find_threshold_by_max_metric(performance_h2o, \"f1\")) +\n    labs(title = \"Precision vs Recall\", y = \"value\") +\n    theme_minimal()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\n#> ℹ Please use `linewidth` instead.\n```\n:::\n\n::: {.cell-output-display}\n![](Challenge_4_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n::: {.cell hash='Challenge_4_cache/html/unnamed-chunk-9_7841df85a45b2803f6645d3f45509656'}\n\n```{.r .cell-code}\n# Roc plot\nperformance_tbl %>%\n    ggplot(aes(fpr, tpr)) +\n    geom_line(size = 1) +\n    \n    # just for demonstration purposes\n    geom_abline(color = \"red\", linetype = \"dotted\") +\n    \n    theme_minimal() +\n    theme(\n      legend.direction = \"vertical\",\n      ) +\n    labs(\n        title = \"ROC Plot\",\n        subtitle = \"Performance of 3 Top Performing Models\"\n    )\n```\n\n::: {.cell-output-display}\n![](Challenge_4_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n::: {.cell hash='Challenge_4_cache/html/unnamed-chunk-10_46497c535890e444b28fa0564a3115c8'}\n\n```{.r .cell-code}\n# Precision vs Recall\nperformance_tbl %>%\n    ggplot(aes(recall, precision)) +\n    geom_line(size = 1) +\n    theme_minimal() + \n    theme(\n      legend.direction = \"vertical\",\n      ) +\n    labs(\n        title = \"Precision vs Recall Plot\",\n        subtitle = \"Performance of 3 Top Performing Models\"\n    )\n```\n\n::: {.cell-output-display}\n![](Challenge_4_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n::: {.cell hash='Challenge_4_cache/html/unnamed-chunk-11_d1e8d49f6e58a337db19d68086c82942'}\n\n```{.r .cell-code}\ngain_lift_tbl <- performance_h2o %>%\n    h2o.gainsLift() %>%\n    as.tibble()\n\n# Gain Chart\n\ngain_transformed_tbl <- gain_lift_tbl %>% \n    select(group, cumulative_data_fraction, cumulative_capture_rate, cumulative_lift) %>%\n    select(-contains(\"lift\")) %>%\n    mutate(baseline = cumulative_data_fraction) %>%\n    rename(gain     = cumulative_capture_rate) %>%\n    # prepare the data for the plotting (for the color and group aesthetics)\n    pivot_longer(cols = c(gain, baseline), values_to = \"value\", names_to = \"key\")\n\ngain_transformed_tbl %>%\n    ggplot(aes(x = cumulative_data_fraction, y = value, color = key)) +\n    geom_line(size = 1.5) +\n    labs(\n        title = \"Gain Chart\",\n        x = \"Cumulative Data Fraction\",\n        y = \"Gain\"\n    ) +\n    theme_minimal()\n```\n\n::: {.cell-output-display}\n![](Challenge_4_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n::: {.cell hash='Challenge_4_cache/html/unnamed-chunk-12_309809b70df6181c1d02cc7d38f5a8ee'}\n\n```{.r .cell-code}\n# Lift Plot\n\nlift_transformed_tbl <- gain_lift_tbl %>% \n    select(group, cumulative_data_fraction, cumulative_capture_rate, cumulative_lift) %>%\n    select(-contains(\"capture\")) %>%\n    mutate(baseline = 1) %>%\n    rename(lift = cumulative_lift) %>%\n    pivot_longer(cols = c(lift, baseline), values_to = \"value\", names_to = \"key\")\n\nlift_transformed_tbl %>%\n    ggplot(aes(x = cumulative_data_fraction, y = value, color = key)) +\n    geom_line(size = 1.5) +\n    labs(\n        title = \"Lift Chart\",\n        x = \"Cumulative Data Fraction\",\n        y = \"Lift\"\n    ) +\n    theme_minimal()\n```\n\n::: {.cell-output-display}\n![](Challenge_4_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n::: {.cell hash='Challenge_4_cache/html/unnamed-chunk-13_456e435ad00a34ebfc4bf3fbe2c905fc'}\n\n```{.r .cell-code}\n# 5. Performance Visualization ----  \nlibrary(cowplot)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> \n#> Attache Paket: 'cowplot'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Das folgende Objekt ist maskiert 'package:lubridate':\n#> \n#>     stamp\n```\n:::\n\n```{.r .cell-code}\nlibrary(glue)\n\n\n# set values to test the function while building it\nh2o_leaderboard <- automl_models_h2o@leaderboard\nnewdata <- test_tbl\norder_by <- \"auc\"\nmax_models <- 4\nsize <- 1\n\nplot_h2o_performance <- function(h2o_leaderboard, newdata, order_by = c(\"auc\", \"logloss\"),\n                                 max_models = 3, size = 1.5) {\n    \n    # Inputs\n    \n    leaderboard_tbl <- h2o_leaderboard %>%\n        as_tibble() %>%\n        slice(1:max_models)\n    \n    newdata_tbl <- newdata %>%\n        as_tibble()\n    \n    # Selecting the first, if nothing is provided\n    order_by      <- tolower(order_by[[1]]) \n    \n    # Convert string stored in a variable to column name (symbol)\n    order_by_expr <- rlang::sym(order_by)\n\n    # Turn of the progress bars ( opposite h2o.show_progress())\n    h2o.no_progress()\n    \n    # 1. Model metrics\n    \n    get_model_performance_metrics <- function(model_id, test_tbl) {\n        \n        model_h2o <- h2o.getModel(model_id)\n        perf_h2o  <- h2o.performance(model_h2o, newdata = as.h2o(test_tbl))\n        \n        perf_h2o %>%\n            h2o.metric() %>%\n            as.tibble() %>%\n            select(threshold, tpr, fpr, precision, recall)\n        \n    }\n    \n    model_metrics_tbl <- leaderboard_tbl %>%\n        mutate(metrics = map(model_id, get_model_performance_metrics, newdata_tbl)) %>%\n        unnest(cols = metrics) %>%\n        mutate(\n          model_id = as_factor(model_id) %>% \n                      # programmatically reorder factors depending on order_by\n                      fct_reorder(!! order_by_expr, \n                                  .desc = ifelse(order_by == \"auc\", TRUE, FALSE)),\n          auc      = auc %>% \n                      round(3) %>% \n                      as.character() %>% \n                      as_factor() %>% \n                      fct_reorder(as.numeric(model_id)),\n          logloss  = logloss %>% \n                      round(4) %>% \n                      as.character() %>% \n                      as_factor() %>% \n                      fct_reorder(as.numeric(model_id))\n        )\n    \n    \n    # 1A. ROC Plot\n    \n    p1 <- model_metrics_tbl %>%\n        ggplot(aes(fpr, tpr, color = model_id, linetype = !! order_by_expr)) +\n        geom_line(size = size) +\n        theme_minimal() +\n        labs(title = \"ROC\", x = \"FPR\", y = \"TPR\") +\n        theme(legend.direction = \"vertical\") \n        \n    \n    # 1B. Precision vs Recall\n    \n    p2 <- model_metrics_tbl %>%\n        ggplot(aes(recall, precision, color = model_id, linetype = !! order_by_expr)) +\n        geom_line(size = size) +\n        theme_minimal() +\n        labs(title = \"Precision Vs Recall\", x = \"Recall\", y = \"Precision\") +\n        theme(legend.position = \"none\") \n    \n    \n    # 2. Gain / Lift\n    \n    get_gain_lift <- function(model_id, test_tbl) {\n        \n        model_h2o <- h2o.getModel(model_id)\n        perf_h2o  <- h2o.performance(model_h2o, newdata = as.h2o(test_tbl)) \n        \n        perf_h2o %>%\n            h2o.gainsLift() %>%\n            as.tibble() %>%\n            select(group, cumulative_data_fraction, cumulative_capture_rate, cumulative_lift)\n        \n    }\n    \n    gain_lift_tbl <- leaderboard_tbl %>%\n        mutate(metrics = map(model_id, get_gain_lift, newdata_tbl)) %>%\n        unnest(cols = metrics) %>%\n        mutate(\n            model_id = as_factor(model_id) %>% \n                fct_reorder(!! order_by_expr, \n                            .desc = ifelse(order_by == \"auc\", TRUE, FALSE)),\n            auc  = auc %>% \n                round(3) %>% \n                as.character() %>% \n                as_factor() %>% \n                fct_reorder(as.numeric(model_id)),\n            logloss = logloss %>% \n                round(4) %>% \n                as.character() %>% \n                as_factor() %>% \n                fct_reorder(as.numeric(model_id))\n        ) %>%\n        rename(\n            gain = cumulative_capture_rate,\n            lift = cumulative_lift\n        ) \n    \n    # 2A. Gain Plot\n    \n    p3 <- gain_lift_tbl %>%\n        ggplot(aes(cumulative_data_fraction, gain, \n                          color = model_id, linetype = !! order_by_expr)) +\n        geom_line(size = size,) +\n        geom_segment(x = 0, y = 0, xend = 1, yend = 1, \n                     color = \"red\", size = size, linetype = \"dotted\") +\n        theme_minimal() +\n        expand_limits(x = c(0, 1), y = c(0, 1)) +\n        labs(title = \"Gain\",\n             x = \"Cumulative Data Fraction\", y = \"Gain\") +\n        theme(legend.position = \"none\")\n    \n    # 2B. Lift Plot\n    \n    p4 <- gain_lift_tbl %>%\n        ggplot(aes(cumulative_data_fraction, lift, \n                          color = model_id, linetype = !! order_by_expr)) +\n        geom_line(size = size) +\n        geom_segment(x = 0, y = 1, xend = 1, yend = 1, \n                     color = \"red\", size = size, linetype = \"dotted\") +\n        theme_minimal() +\n        expand_limits(x = c(0, 1), y = c(0, 1)) +\n        labs(title = \"Lift\",\n             x = \"Cumulative Data Fraction\", y = \"Lift\") +\n        theme(legend.position = \"none\") \n    \n    \n    # Combine using cowplot\n    \n    # cowplot::get_legend extracts a legend from a ggplot object\n    p_legend <- get_legend(p1)\n    # Remove legend from p1\n    p1 <- p1 + theme(legend.position = \"none\")\n    \n    # cowplot::plt_grid() combines multiple ggplots into a single cowplot object\n    p <- cowplot::plot_grid(p1, p2, p3, p4, ncol = 2)\n    \n    # cowplot::ggdraw() sets up a drawing layer\n    p_title <- ggdraw() + \n    \n        # cowplot::draw_label() draws text on a ggdraw layer / ggplot object\n        draw_label(\"H2O Model Metrics\", size = 18, fontface = \"bold\", \n                   color = \"#2C3E50\")\n    \n    p_subtitle <- ggdraw() + \n        draw_label(glue(\"Ordered by {toupper(order_by)}\"), size = 10,  \n                   color = \"#2C3E50\")\n    \n    # Combine everything\n    ret <- plot_grid(p_title, p_subtitle, p, p_legend, \n    \n                     # Adjust the relative spacing, so that the legends always fits\n                     ncol = 1, rel_heights = c(0.05, 0.05, 1, 0.05 * max_models))\n    \n    h2o.show_progress()\n    \n    return(ret)\n    \n}\n\nautoml_models_h2o@leaderboard %>%\n    plot_h2o_performance(newdata = test_tbl, order_by = \"logloss\", \n                         size = 0.5, max_models = 4)\n```\n\n::: {.cell-output-display}\n![](Challenge_4_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}